---
title: python闭包中的作用域
date: 2016-11-28 19:43:06
tags:
---
python的闭包带来许多让人十分畅快的特性，但在使用闭包的时候也有许多要注意的地方，尤其是闭包的**作用域**，下面就来谈谈Python闭包中的作用域。看下面一段代码，试想一下最后打印的是什么值。

```python
def outer():
    flag = False

    def inner():
        flag = True
    inner()
    return flag

if __name__ == '__main__':
    print(outer())
```

如果你的答案是`True`那就说明你进坑了，为了说明为什么答案是`False`我们先来看看python是如何来判断变量的作用域的。python解释器会按照下面的顺序来，来解析变量的引用：
> 
1. 当前函数的作用域
2. 任何外围的作用域（如包含当前函数的其他函数）
3. 包含当前代码的那个模块的作用域（也叫全局作用域，global scope)
4. 内置作用域

也就是说在`inner()`方法中的`flag = True`,并不是将`False`赋值给了外层的`flag`变量。而是这个`flag`是一个新的变量，因为符合第一条规则，就不会按照后面的方式去解析了，所以这个变量只在当前的函数作用域生效,最后打印出的值也就是是`False`。
当然，介绍你一定希望在内层函数中改变外层的变量，你可以加上`nonlocal`关键字，将这个变量作用域作用到外层函数上。
