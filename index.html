<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  <meta property="og:image" content="/favicon.ico">
  
  <title>dashen&#39;s blog</title>

  
  <meta name="author" content="Da Shen">
  

  
  <meta name="description" content="Da Shen&#39;s blog">
  

  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  

  <meta property="og:site_name" content="dashen&#39;s blog"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="dashen&#39;s blog" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
</head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">dashen&#39;s blog</a>
    </h1>
    <p class="site-description"></p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">Home</a></li>
      
        <li><a href="/archives">Archives</a></li>
      
        <li><a href="https://github.com/DashShen/">Github</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    
  <article>

  
    
    <h3 class="article-title"><a href="/2017/1/3/java并发编程实战笔记（一）/"><span>java并发编程实战笔记（一）</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2017/1/3/java并发编程实战笔记（一）/" rel="bookmark">
        <time class="entry-date published" datetime="2017-01-03T12:24:37.000Z">
          2017-01-03
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <ol>
<li>线程安全的定义</li>
</ol>
<ul>
<li><p>线程安全其实并没有一个很公认的准确的定义，只能说一下自己的理解</p>
<blockquote>
<p>当多个线程访问某个类的时候，不管是采用何种调度方式去调用，调用方不需要添加额外的同步或者协同机制，这个类都能返回正确的结果，那么就成这个类是一个线程安全的类。</p>
</blockquote>
</li>
<li><p>无状态的对象是线程安全，因此<code>servlet</code>是线程安全的</p>
</li>
</ul>
<ol>
<li><p>竞态条件<br>竞态条件就是说，程序执行的正确结果是依赖于某种运气条件，比如依赖于一个没有同步机制的共享状态变量。常见的会产生竞态情况有</p>
<ul>
<li>Check-Then-Act(懒加载)</li>
<li>Read-Modify-Write(没有同步机制的去读写共享变量)</li>
<li>Put-if-absent</li>
<li>当几个原子方法组成的复合操作时，也可能出现竞态的出现<br>竞态条件通常会导致不可预测的结果，例如<strong>懒加载</strong>生成多个对象，<strong>共享变量</strong>的结果出错。</li>
</ul>
</li>
<li><p>内置锁和重入</p>
</li>
</ol>
<ul>
<li><code>synchronized</code>会使用自身的对象作为锁，<code>synchronized</code>修饰的方法使用<code>Class</code>对象作为锁</li>
<li>当一个线程去请求获得一个自己已经持有的锁，那么这个请求就会成功。如：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</div><div class="line">        .....</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">//doSomething</span></div><div class="line">        <span class="keyword">super</span>.doSomething();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>假设没有重入机制，那么将会产生死锁，因为<code>Son</code>的对象获得了<code>Father</code>上的锁，之后<code>super.doSomething()</code>也想获得<code>Father</code>上的锁，因此这就产生了死锁。因为有了重入机制，就不会产生这个死锁的情况。</p>
<ol>
<li><p>使用锁来保护状态</p>
<ul>
<li>对于可能被多个线程同时访问的可变状态变量，在访问它时都需要只有一个锁</li>
<li>当一个类的不变性条件设计多个状态变量，则其中涉及的多有变量都需要由同一个锁来保护</li>
</ul>
</li>
</ol>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2016/12/26/玩玩VimOS/"><span>玩玩VimOS</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2016/12/26/玩玩VimOS/" rel="bookmark">
        <time class="entry-date published" datetime="2016-12-26T13:52:45.000Z">
          2016-12-26
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>最近发现Ubuntu 16.04版本自带xmodmap,自己又搞了一块poker键盘，这键盘又没有方向键。于是乎遍想能不能通过xmodmap把方向键映射成vim的<code>hjkl</code>。尝试了一阵之后，我将caps这种无用的键去了，之后进行上下左右操作只要<code>caps</code> + <code>hjkl</code>。先创建文件<code>~/.xmodmap.conf</code>,然后添加下面的配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">clear Lock</div><div class="line">keycode 66 = Mode_switch</div><div class="line"></div><div class="line">! navigation shortcuts</div><div class="line">keycode 43 = h H Left</div><div class="line">keycode 44 = j J Down</div><div class="line">keycode 45 = k K Up</div><div class="line">keycode 46 = l L Right</div></pre></td></tr></table></figure>
<p>保存后执行,就可以使用<code>caps</code>+<code>hjkl</code>进行上下左右移动了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">xmodmap .xmodmap</div></pre></td></tr></table></figure>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2016/11/28/python闭包中的作用域/"><span>python闭包中的作用域</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2016/11/28/python闭包中的作用域/" rel="bookmark">
        <time class="entry-date published" datetime="2016-11-28T11:43:06.000Z">
          2016-11-28
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>python的闭包带来许多让人十分畅快的特性，但在使用闭包的时候也有许多要注意的地方，尤其是闭包的<strong>作用域</strong>，下面就来谈谈Python闭包中的作用域。看下面一段代码，试想一下最后打印的是什么值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">outer</span><span class="params">()</span>:</span></div><div class="line">    flag = <span class="keyword">False</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></div><div class="line">        flag = <span class="keyword">True</span></div><div class="line">    inner()</div><div class="line">    <span class="keyword">return</span> flag</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    print(outer())</div></pre></td></tr></table></figure>
<p>如果你的答案是<code>True</code>那就说明你进坑了，为了说明为什么答案是<code>False</code>我们先来看看python是如何来判断变量的作用域的。python解释器会按照下面的顺序来，来解析变量的引用：</p>
<blockquote>
<ol>
<li>当前函数的作用域</li>
<li>任何外围的作用域（如包含当前函数的其他函数）</li>
<li>包含当前代码的那个模块的作用域（也叫全局作用域，global scope)</li>
<li>内置作用域</li>
</ol>
</blockquote>
<p>也就是说在<code>inner()</code>方法中的<code>flag = True</code>,并不是将<code>False</code>赋值给了外层的<code>flag</code>变量。而是这个<code>flag</code>是一个新的变量，因为符合第一条规则，就不会按照后面的方式去解析了，所以这个变量只在当前的函数作用域生效,最后打印出的值也就是是<code>False</code>。<br>当然，介绍你一定希望在内层函数中改变外层的变量，你可以加上<code>nonlocal</code>关键字，将这个变量作用域作用到外层函数上。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2016/11/18/乱谈python中的函数/"><span>乱谈python中的函数属性</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2016/11/18/乱谈python中的函数/" rel="bookmark">
        <time class="entry-date published" datetime="2016-11-18T13:36:35.000Z">
          2016-11-18
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>在python中一切都是对象，包括函数。今天就来随便聊聊这个函数，聊聊这个函数的属性的问题。</p>
<p>首先，我们来先定义一个函数，然后调用<code>dir()</code>方法看看这个函数里面有什么属性和方法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></div><div class="line"><span class="meta">... </span>    <span class="keyword">pass</span></div><div class="line">...</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>dir(func)</div><div class="line">[<span class="string">'__call__'</span>, <span class="string">'__class__'</span>, <span class="string">'__closure__'</span>, <span class="string">'__code__'</span>, <span class="string">'__defaults__'</span>,<span class="string">'__delattr__'</span>, <span class="string">'__dict__'</span>, <span class="string">'__doc__'</span>, <span class="string">'__format__'</span>, <span class="string">'__get__'</span>, <span class="string">'__getattribute__'</span>, <span class="string">'__globals__'</span>, <span class="string">'__hash__'</span>, <span class="string">'__init__'</span>, <span class="string">'__module__'</span>, <span class="string">'__name__'</span>, <span class="string">'__new__'</span>, <span class="string">'__reduce__'</span>, <span class="string">'__reduce_ex__'</span>, <span class="string">'__repr__'</span>, <span class="string">'__setattr__'</span>, <span class="string">'__sizeof__'</span>, <span class="string">'__str__'</span>, <span class="string">'__subclasshook__'</span>, <span class="string">'func_closure'</span>, <span class="string">'func_code'</span>, <span class="string">'func_defaults'</span>, <span class="string">'func_dict'</span>, <span class="string">'func_doc'</span>, <span class="string">'func_globals'</span>, <span class="string">'func_name'</span>]</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure>
<p>咦，我怎么发现了两个大大的<code>__setattr__</code>和<code>__getattribute__</code>魔术方法呢(⊙o⊙)?。也就是说我可以这样子玩，<code>func.foo = bar</code>, 然后再这样子 <code>print func.foo</code>,打印出<code>bar</code>。我的天，感觉我好像在写<code>js</code>哇，既然这样子，那我这样子玩玩看´ψ(｀∇´)ψ`。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> functools</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_foo</span><span class="params">(func)</span>:</span></div><div class="line"><span class="meta">    @functools.wraps(func)</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorator</span><span class="params">(*args, **kwargs)</span>:</span></div><div class="line">        func.foo = <span class="string">'bar'</span></div><div class="line">        func(*args, **kwargs)</div><div class="line">    <span class="keyword">return</span> decorator</div><div class="line"></div><div class="line"><span class="meta">@set_foo</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">print</span> func.foo</div><div class="line"></div><div class="line">func()</div></pre></td></tr></table></figure>
<p>照理来说我们应该会看到<code>bar</code>, 但是这是什么鬼，为什么没有<code>foo</code>属性呢, 我都已经在装饰器里面给这个<code>func</code>加了<code>foo</code>的属性了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ python test.py                                                                                                         </div><div class="line">Traceback (most recent call last):                                                                                       </div><div class="line">  File &quot;test.py&quot;, line 16, in &lt;module&gt;                                                                                   </div><div class="line">    func()                                                                                                               </div><div class="line">  File &quot;test.py&quot;, line 14, in func                                                                                       </div><div class="line">    print func.foo                                                                                                       </div><div class="line">AttributeError: &apos;function&apos; object has no attribute &apos;foo&apos;</div></pre></td></tr></table></figure>
<p>我怀疑这个在<code>def decorator(*args, **kwargs)</code>中的<code>func</code>，和在<code>def func()</code>中的<code>func</code>不会不是同一个本体吧。于是，我拿出<code>print id(func)</code>大法，看看这个两货本体究竟是谁 (`皿´)。 </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorator</span><span class="params">(*args, **kwargs)</span>:</span></div><div class="line">    <span class="keyword">print</span> id(func)</div><div class="line">...</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">print</span> id(func)</div></pre></td></tr></table></figure>
<p>OMG, 这两货居然真的不是同一个本体。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ python test.py</div><div class="line">4538443128</div><div class="line">4538443248</div></pre></td></tr></table></figure></p>
<p>也就是说，我在装饰器中给<code>func</code>加的<code>foo</code>属性，并不是加在真正本体上了，那么真正的本体在去哪里了。最后我发现了，其实代码应该这么写。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorator</span><span class="params">(*args, **kwargs)</span>:</span></div><div class="line">    decorator.foo = <span class="string">'bar'</span></div><div class="line">...</div></pre></td></tr></table></figure>
<p>然后我再执行，就发现没有问题了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ python test.py</div><div class="line">bar</div></pre></td></tr></table></figure>
<p>原来如此呀，原来<code>decorator</code>才是本体呀( ⊙ o ⊙ )！。至于为什么是这样解决这个问题的，我们可以去看一下python的<strong>装饰器</strong>, <strong>闭包</strong>等这些概念,然后去看一下解释器在解释执行的为什么会生成两个不同的函数对象。最后强烈建议，开发python的开发者，可以出一个方法，用于在函数内部表示函数的自身调用。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2016/11/8/解决ubuntu无法使用http进行docker push/"><span>解决ubuntu中docker无法使用http进行push</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2016/11/8/解决ubuntu无法使用http进行docker push/" rel="bookmark">
        <time class="entry-date published" datetime="2016-11-08T13:24:08.000Z">
          2016-11-08
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>默认情况下docker是使用https进行push的，当我们配置了自己的docker registry且使用http来上传镜像的时候，就需要配置我们ubuntu环境下的docker配置文件。</p>
<ul>
<li>在 <code>/etc/default/docker</code> 文件中添加一行</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">DOCKER_OPTS=&quot;--insecure-registry YOUR_REGISTRY_DOMAIN&quot;</div></pre></td></tr></table></figure>
<p>然后保存退出，根据<a href="https://docs.docker.com/registry/insecure/" target="_blank" rel="external">官网的文档</a>,我们只需要重启我们的docker守护进程就可以了。但是再尝试之后一直发现无效，最后才发现原来是docker在ubuntu环境下有坑，不会加载<code>/etc/default/docker</code>这个配置文件，下面就是解决办法。</p>
<ul>
<li><p>修改 <code>/lib/systemd/system/docker.service</code><br>  1.增加一行，用于指定配置文件在什么地方</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">EnvironmentFile=-/etc/default/docker</div></pre></td></tr></table></figure>
<p>  2.然后将</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ExecStart=/usr/bin/docker daemon -H fd://</div></pre></td></tr></table></figure>
<p>  修改为</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ExecStart=/usr/bin/docker daemon -H fd:// $DOCKER_OPTS</div></pre></td></tr></table></figure>
<p>  注意<code>fd://</code>之后又一个空格</p>
</li>
<li><p>重启docker服务<br>  1.执行</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo systemctl daemon-reload</div></pre></td></tr></table></figure>
<p>  2.重启docker</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo systemctl restart docker</div></pre></td></tr></table></figure>
<p>  3.这个时候，通过这个命令就可以看到docker的配置文件了</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo systemctl show docker | grep EnvironmentFile</div></pre></td></tr></table></figure>
</li>
</ul>
<p>最后再次尝试<code>docker push</code>就可以成功上传镜像了。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2016/10/31/阻塞IO-非阻塞IO的c实现/"><span>阻塞IO，非阻塞IO的c实现</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2016/10/31/阻塞IO-非阻塞IO的c实现/" rel="bookmark">
        <time class="entry-date published" datetime="2016-10-31T10:16:07.000Z">
          2016-10-31
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>一般理解阻塞IO与非阻塞IO基本都是基于文字描述，然后举一个浅显易懂的例子来解释这两个概念。这里我就使用c写两个关于阻塞IO,以及非阻塞IO的例子，会使用到pipe来创建一个管道，利用这个管道,让父进程与子进程之间进行通信，来模拟IO事件。</p>
<h1 id="阻塞IO"><a href="#阻塞IO" class="headerlink" title="阻塞IO"></a>阻塞IO</h1><p>阻塞IO的代码相对简单，只需要创建管道，然后fork出子进程，父进程发送消息，子进程接受消息。但是，父进程不是立即发送消息，而是等到三秒之后再发送消息，因此子进程只能到消息的到来才能往下执行。代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> fds[<span class="number">2</span>];</div><div class="line">  <span class="keyword">char</span> buf[<span class="number">1024</span>];</div><div class="line">  <span class="keyword">pid_t</span> pid;</div><div class="line">  pipe(fds);</div><div class="line">  <span class="keyword">int</span> r = fds[<span class="number">0</span>], w = fds[<span class="number">1</span>];</div><div class="line">  pid = fork();</div><div class="line">  <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</div><div class="line">    <span class="keyword">char</span> msg[] = <span class="string">"This msg was sended from father"</span>;</div><div class="line">    <span class="comment">// 三秒之后再向自进程发送消息</span></div><div class="line">    sleep(<span class="number">3</span>);</div><div class="line">    write(w, msg, <span class="keyword">sizeof</span>(msg));</div><div class="line">    close(r);</div><div class="line">    close(w);</div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"No message and process is blocking\n"</span>);</div><div class="line">    <span class="comment">// read方法会阻塞，因为还没有收到消息</span></div><div class="line">    read(r, buf, <span class="keyword">sizeof</span>(buf));</div><div class="line">    <span class="comment">// 接收到消息之后，再打印输出</span></div><div class="line">    <span class="built_in">printf</span>(<span class="string">"Get message from father: %s\n"</span>, buf);</div><div class="line">    close(r);</div><div class="line">    close(w);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>用于是阻塞的，所以在编译执行代码之后,会在这里卡住：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ gcc blocking.c</div><div class="line">$ ./a.out</div><div class="line">No message and process is blocking</div></pre></td></tr></table></figure>
<p>然后三秒钟之后，父进程发送消息了，子进程收到之后，将消息打印至控制台：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ No message and process is blocking                                                                                       </div><div class="line">$ Get message from father: This msg was sended from father</div></pre></td></tr></table></figure>
<h1 id="非阻塞IO"><a href="#非阻塞IO" class="headerlink" title="非阻塞IO"></a>非阻塞IO</h1><p>非阻塞IO现对于阻塞IO的实现稍微复杂一点，会用到fcntl方法去修改文件描述的状态。将管道的读端的文件描述符该为非阻塞的,然后调用read()方法后，进程不会阻塞，而是会一直去询问是否有IO流到来。如果没有数据到来，则read()方法会返回-1,如果有数据，则会返回数据的长度。下面是具体代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_noblocking</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> fds[<span class="number">2</span>];</div><div class="line">  <span class="keyword">char</span> buf[<span class="number">1024</span>];</div><div class="line">  <span class="keyword">pid_t</span> pid;</div><div class="line">  pipe(fds);</div><div class="line">  <span class="keyword">int</span> r = fds[<span class="number">0</span>], w = fds[<span class="number">1</span>];</div><div class="line">  set_noblocking(r);</div><div class="line">  pid = fork();</div><div class="line">  <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</div><div class="line">    <span class="keyword">char</span> msg[] = <span class="string">"This msg was sended from father"</span>;</div><div class="line">    <span class="comment">// 五秒之后再发送消息</span></div><div class="line">    sleep(<span class="number">5</span>);</div><div class="line">    write(w, msg, <span class="keyword">sizeof</span>(msg));</div><div class="line">    close(r);</div><div class="line">    close(w);</div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</div><div class="line">    <span class="keyword">int</span> not_ready = <span class="number">-1</span>;</div><div class="line">    <span class="keyword">while</span> (not_ready &lt; <span class="number">0</span>) &#123;</div><div class="line">      <span class="comment">// 每隔一秒轮询消息是否到来</span></div><div class="line">      sleep(<span class="number">1</span>);</div><div class="line">      <span class="built_in">printf</span>(<span class="string">"Reader not ready\n"</span>);</div><div class="line">      not_ready = read(r, buf, <span class="keyword">sizeof</span>(buf));</div><div class="line">      <span class="built_in">printf</span>(<span class="string">"Value of read() reaturned %d\n"</span>, not_ready);</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"Get message from father: %s\n"</span>, buf);</div><div class="line">    close(r);</div><div class="line">    close(w);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_noblocking</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>&#123;</div><div class="line">  <span class="comment">// 设置成为为阻塞的fd</span></div><div class="line">  <span class="keyword">int</span> flags = fcntl(fd, F_GETFL);</div><div class="line">  fcntl(fd, F_SETFL, flags | O_NONBLOCK);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>非阻塞IO的执行结果,由于子进程会每隔一秒去询问是否有数据到来，如果没有带来，则会打印not ready。5秒之后，父进程发出了一条消息，子进程收到之后就将消息打印了出来。这样子就模拟了一次非阻塞IO的过程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">$ gcc noblocking.c</div><div class="line">$ ./a.out</div><div class="line">Reader not ready                                                                                                         </div><div class="line">Value of read() reaturned -1                                                                                             </div><div class="line">Reader not ready                                                                                                         </div><div class="line">Value of read() reaturned -1                                                                                             </div><div class="line">Reader not ready                                                                                                         </div><div class="line">Value of read() reaturned -1                                                                                             </div><div class="line">Reader not ready                                                                                                         </div><div class="line">Value of read() reaturned -1                                                                                             </div><div class="line">Reader not ready                                                                                                         </div><div class="line">Value of read() reaturned 32                                                                                             </div><div class="line">Get message from father: This msg was sended from father</div></pre></td></tr></table></figure>
<p>总的来说，阻塞的IO会使当前进程一直等到数据的到来，要不然不会执行后续的代码，而非阻塞的情况正好相反。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2016/10/22/解决flask-restful无法使用-app-errorhandler/"><span>解决flask_restful无法使用@app.errorhandler</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2016/10/22/解决flask-restful无法使用-app-errorhandler/" rel="bookmark">
        <time class="entry-date published" datetime="2016-10-22T06:01:08.000Z">
          2016-10-22
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>在使用<code>flask_restful</code>插件开发RESTfulAPI的时候，会发现无法在非debug模式下使用flask的<code>@app.errorhandler</code>装饰器来捕获处理自己定义自己的异常，这是一件比较让人头痛的事情。经过对restful插件的源码阅读之后，想到了一种解决这个问题的办法。便是定义一个装饰器，用于捕获处理自定义异常，然后在每一个<code>get/post</code>等方法上注册这个装饰器。<br>先放上部分异常声明代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ASError</span><span class="params">(Exception)</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, status, code, message)</span>:</span></div><div class="line">        self._status = status</div><div class="line">        self._code = code</div><div class="line">        self._message = message</div><div class="line"></div><div class="line"><span class="meta">    @property</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">status</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self._status</div><div class="line"></div><div class="line"><span class="meta">    @property</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">code</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self._code</div><div class="line"></div><div class="line"><span class="meta">    @property</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">message</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self._message</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ASBadRequest</span><span class="params">(ASError)</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, code, message)</span>:</span></div><div class="line">        super(ASBadRequest, self).__init__(<span class="number">400</span>, code, message)</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ASArgMissing</span><span class="params">(ASBadRequest)</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, msg)</span>:</span></div><div class="line">        super(ASArgMissing, self).__init__(_ARG_MISSING, msg)</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ASArgFormat</span><span class="params">(ASBadRequest)</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, msg)</span>:</span></div><div class="line">        super(ASArgFormat, self).__init__(_ARG_FORMART, msg)</div><div class="line">...</div></pre></td></tr></table></figure>
<p>然后是异常处理的装饰器代码:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">errorhandler</span><span class="params">(func)</span>:</span></div><div class="line"><span class="meta">    @wraps(func)</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></div><div class="line">        <span class="keyword">try</span>:</div><div class="line">            resp = func(*args, **kwargs)</div><div class="line">            <span class="keyword">return</span> resp</div><div class="line">        <span class="keyword">except</span> ASError <span class="keyword">as</span> err:</div><div class="line">            status = err.status()</div><div class="line">            respMsg = jsonify(&#123;<span class="string">'status'</span>: err.code(), <span class="string">'message'</span>: err.message()&#125;)</div><div class="line">            <span class="keyword">return</span> make_response(respMsg, status)</div><div class="line">    <span class="keyword">return</span> wrapper</div></pre></td></tr></table></figure>
<p>然后是在<code>get/post</code>等方法上注册这个装饰器，这里当然不会在每一个方法上使用@errohandler,这样子太丑了。比较好的做法是这样子, 向api的decorators属性传入一个装饰器的列表，列表中的所有装饰器会作用到每一个<code>get/post</code>等方法上去。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">app = Flask(__name__)</div><div class="line">api = Api(app, decorators=[errorhandler])</div></pre></td></tr></table></figure>
<p>这样就可以避免使用<code>@app.errorhandler</code>,而导致在非debug模式下，异常无法被捕获。最后附上<a href="https://github.com/DashShen/flask-restful-template" target="_blank" rel="external">github</a>地址。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2016/10/21/理解同步-异步-阻塞-非阻塞/"><span>理解同步,异步,阻塞,非阻塞</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2016/10/21/理解同步-异步-阻塞-非阻塞/" rel="bookmark">
        <time class="entry-date published" datetime="2016-10-21T15:05:28.000Z">
          2016-10-21
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>同步与异步，阻塞与非阻塞的概念经常让人混淆不清。其实在理解这这两组概念上，主要还是区分他们是用来形容什么的。</p>
<h1 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h1><p>同步和异步通常是用来形容一次<code>方法调用</code>的。同步方法调用一旦开始，调用者必须等到被调用的方法返回之后才能继续执行后续的任务。而异步方法调用,更像是一种消息传递，调用者调用了调用的方法后，可以立即继续执行后续的任务，不用等被调用方法返回结果后再往下执行。举一个实际的例子：</p>
<blockquote>
<p>比如你现在出门购物，要买一台电视机，你跑到家电市场，看中一台电视机，你就想售货员下单。但是这个时候，售货员告诉你，这款电视机现在没有，必须去仓库里拿。这个时候你就不得不在市场李候着他们，催着他们赶紧把电视机送过来，直到把你商家把你和电视机一起送回家。这就是<strong>同步调用</strong>, 你今天的买电视机的后续事情，都必须等到电视机买到之后才可以继续完成。</p>
<p>不过，现在都是网购了，你还是想要一台电视机，你看中型号和款式，便在网上支付。此时买电视机这件事情对你来说已经结束了，之后你想做什么就做什么。因为你知道商家正在加紧安排送货，届时会联系你，你只需要回家收电视机就好了.这就是<strong>异步调用</strong></p>
</blockquote>
<h1 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h1><p>为什么要在这里解释一下临界区的概念呢，因为这对于理解阻塞与非阻塞的概念是十分必要的。临界区是用来表示一种<code>公共资源</code>或者说是<code>共享数据</code>,可以被多个线程使用，但是每一次，只能有一个线程可以使用它。也就是说<code>临界区资源</code>被占用，其他线程想使用，就必须等待。比如：</p>
<blockquote>
<p>办公室中的一台打印机，就是公共资源，但是打印机一个时间只能有一个人可以使用,其他人使用就必须等到这个人打印结束之后才可以使用。</p>
</blockquote>
<h1 id="阻塞与非阻塞"><a href="#阻塞与非阻塞" class="headerlink" title="阻塞与非阻塞"></a>阻塞与非阻塞</h1><p>在理解临界区的概念之后，便可以来讲一下阻塞与非阻塞的概念了。阻塞与非阻塞通常用来形容<code>多线程间的相互影响</code>。比如一个线程占用了临界区资源，那么其他所有需要这个资源线程就必须在这个临界去中等待，等待会导致线程挂起，这就是<code>阻塞</code>。而<code>非阻塞</code>正好相反，它强调没有一个线程可以妨碍其他线程的执行，所有的线程都会尝试不断向前执行。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>




<nav class="pagination">
  
  
</nav>
    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
    
    &copy; 2017 Da Shen
    
  </p>
</footer>
    
<script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
            m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-86696667-1', 'auto');
    ga('send', 'pageview');

</script>

  </div>
</div>
</body>
</html>